# Reading a problem
- Read the problem slowly.
- Make sure every statement doesnt conflict with your understanding.
- DO NOT IGNORE CONSTRAINTS.
	- Ignoring constraints can make you solve a complex problem trivially $n\le10^{18}$ 
	- Ignoring constraints can make you solve a trivial problem in a complex way $n<10$
	- Constraints turn a general problem into a more special case, which can have a simpler solution.
- Sometimes samples are trivial!
	- Think of all basic cases.
	- Think of special cases.
	- Think of extreme cases:
		- Smallest possible.
		- Largest possible.
- Reread the problem.
# Thinking 
- Have the idea sketched out in your mind or on paper before coding.
- Brainstorm different possible solutions (DP, greedy, ad-hoc)
	- Try to do the most probable idea.
	- If a lot of time passes try to do the next most probable.
	- No idea is a bad idea.
- If you're stuck try a bruteforce solution (sometimes the solution is a faster bruteforce based on an observation).
	- See if you can observe facts/patterns.
- If youre stuck try to restate the problem in another way.
- If you have queries you can sometimes simplify the problem by sorting them.

## Problem Abstraction
We redefine a problem in a more generic way.
>Minimum cost to convert string A to string B.
>We can abstract it to the shortest path from node A to node B.

It helps us find the target algorithm faster.
Be careful to not drop important constraints or characteristics. 

## Reversing a Problem.
Often the reverse of a problem is a lot faster to find.
>Given an increasing/decreasing sequence like Fibonacci, given a value, find its index. --->
>Given an index find its value. 
>Then binary search until we match the original value.

## Problem Simplification
This can help building up intuition.

- Most hard problems are made up of sub-problems.
	- If we get stuck on a subproblem we can always try to formulate a different division into subproblems.

- We can think of a special problem, and then try to transition into the main case.
	- We should always have a vision on how to transition to not waste time.
>Given a 2d array -> What if the array is $1*1$? $2*1$? $1*2$? $2*2$?
>Given a polygon -> What if its a triangle? How about a square? How about a convex polygon?

- We can make some assumptions to make intuition easier.
>We have to find X Y and Z but cant think of them together.
>What if we already solved X, how would we solve Y and Z? What if we already solved X and Y, how would we solve Z?

## Thinking incrementally
We can process the input step by step, getting each step from a modification of the previous one.
>Sort N numbers. 
>Lets say we have already sorted the first m numbers, how do we add the m+1 item?

If updating from one state to another is in constant space and follows a pattern, we can use [[Matrix Exponentiation]].

# Domain re-interpretation
Sometimes rethinking a problem in another domain makes solving it faster.

>Given some boxes, each contains a key and is opened by another key. Given a starting key can we open all of them? 
>We can think of keys as nodes. We move between keys by opening boxes. The solution is an eulerian path.

# Properties
We can read the testcases (from smaller to larger) to try to discover properties and patters.
For example:
- Sparseness 
	- From state $X$ you go to state $X/2$, so theres only $logX$ states.
- Constrained input
	- Not all input combinations are valid.
- Symmetry
- Redundancy
	- Some details can be simplified.
		- For example if we have a button that can be on or off, and it doesnt matter how many times its clicked we can just store 2 states.
- Independency
	- A problem can be reduced to the sum of its parts.
		- The manhattan distance is the x dist + the y dist
		- When trials are independent, sum of the expectations= expectation of the sum.

There might be patterns in how the input is built:
- Some values repeat
- The input is generated by a formula
- A graph is created by repeating certain instructions

Find all numbers with property $P$.
- We can either try all numbers and check if they have property $P$.
- We can generate them based on characteristics of the numbers.

>We can also try splitting big objects and merging smaller objects.

##### Atmost vs exact
$$
atmost(n)=exact(1)+exact(2)...exact(n)
$$
$$
exact(n)=atmost(n)-atmost(n-1)
$$

# Found the solution
- Test the solution with test cases from:
	- The statement
	- Edge cases
- Check if the solution fits within space and time
- Formulate the FULL logic.
	- Check for overflow.
	- Is a recursive solution fine or do we need an iterative one?

After writing
- Check if the code does what its intended, make sure you understand every line.
- Try corner cases.

# Error Handling
### General
- Did it read the entire input
- Did it correctly switch between test cases
- Is the $\infty$ val correct
- Are you taking MOD of negative values
- Are you doing MOD and division

## Wrong answer
- Pick an example, and trace it.
- Reread the text description.
- Check the stopping conditions.

- Overflow
	- Are you using bitmasks where $N>=32$
	- is the code a mix of ints and long longs

## Time limit exceeded
- Is there an infinite loop
	- Are we correctly marking what we have visited
	- Is the DP recurrence correct
- Can the results be precomputed
- Can you optimize the order of the operations
- Can you optimize the break conditions
- Can you optimize the number of function calls

## Other crashes
- Are we accessing an array out of bounds
- Do arrays have the correct size (If 1 indexing set their size to N+1)
- Are using an uninitalized variable

# History
Label the source code of every problem with an id.
Write statistics from every problem you solved:
- ID
- Difficulty
- Category
For every category maintain a list of problems and a list of ideas/solutions for hard problems.
>If you can maintain notes of solutions.


